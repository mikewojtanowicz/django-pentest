from django.test import TestCase
from django.test.utils import override_settings
from django.conf import settings
import django.core.exceptions
import requests
import urllib.request
import json
import pprint
from LegacySite.models import Card, User, Product
from LegacySite.extras import generate_salt, hash_pword, parse_salt_and_password
from django.middleware.csrf import CsrfViewMiddleware, get_token

# Create your tests here.

""" These test cases begin with a fresh database. I approach the problems at hand with this in mind, calling functions as needed."""

REGISTER_URL = "http://127.0.0.1:8000/register.html"
GIFT_URL = "http://127.0.0.1:8000/gift/0"
LOGIN_URL = "http://127.0.0.1:8000/login.html"
BUY_URL = "http://127.0.0.1:8000/buy.html"
USE_URL = "http://127.0.0.1:8000/use.html"

class TestingVulns(TestCase):

    def setUp(self):
        r1 = self.client.post(REGISTER_URL, data = {"uname": "hacker1", "pword": "hacker1", "pword2": "hacker1"})
        self.assertEqual(r1.status_code, 302)
        print("User 1 created!")

        r2 = self.client.post(REGISTER_URL, data = {"uname": "hacker2", "pword": "hacker2", "pword2": "hacker2"})
        self.assertEqual(r2.status_code, 302)
        print("User 2 created!")

        self.product1 = Product(product_id=1, product_name="NYU Apparel Card", product_image_path="/images/product_1.jpg", recommended_price="95", description="Use this card to buy NYU clothing!")
        self.product1.save()

        #self.giftcard = Card({{"merchant_id": "NYU Apparel Card", "customer_id": "hacker2", "total_value": "1000", "records": [{"record_type": "amount_change", "amount_added": 2000, "signature": "a' UNION SELECT password FROM LegacySite_user WHERE LegacySite_user.username = 'admin'; --"}]}})
        #self.giftcard.save()
    
    def testCSRF(self):
        # After much testing, it became evident that you did NOT have to be signed in to gift a card to another user - this was an obvious vector of attack
        r = self.client.get('http://127.0.0.1:8000/gift.html?director=<form action="{}" method="POST"> <input type="hidden" name="amount" value="1111" /> <input type="hidden" name="username" value="hacker2" /> <input type="submit" value="Please Click!"/> </form>'.format(GIFT_URL))
        self.assertEqual(r.status_code, 200)
        print("CSRF failed!")
     
    def testXSS(self):
        # Testing of this web application presented numerous opportuniteis with how 'director' is utilized - it provided many attack possibilites
        payload = {"director": "<script>alert('You've been hacked!')</script>"}
        r = self.client.get('http://127.0.0.1:8000/gift.html?director={}'.format(payload["director"]))
        self.assertEqual(r.status_code, 200)
        print("XSS attack failed!")
    
    def testDebug(self):
        # We can take advantage of django's default settings of debugging turned on to find some more sensitive information that would have otherwise been a 404
       #print(requests.get('http://127.0.0.1:8000/product/2').text)
       r = requests.get('http://127.0.0.1:8000/product/2')
       self.assertEqual(r.status_code, 404)
       print("Debug mode off!")

    def testSQL(self):
        # Logging in with test user
        r = self.client.post(LOGIN_URL, {"uname": "hacker2", "pword": "hacker2"})
        self.assertEqual(r.status_code, 302)
        print("Login worked!")

        with open('./sql.gftcrd', 'r', encoding='utf-8') as payload:
            response = requests.post(USE_URL, {'card_supplied': True, 'card_data': payload})
            card_string = "Card object"
            #print(response.content)
        self.assertEqual(response.status_code, 403)
        print("Debug mode off, SQL did not pick up data!")

        #

        #r2 = self.client.post()

       # the debugger page reveals the URLconf defined in GiftcardSite.urls, their patters, and their input parameters.

    


