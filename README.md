# ðŸ‘¾ Hacking a Django App ðŸ‘¾

Assignment for NYU's Graduate Application Security course:

## Writeups:

### Part 1: Auditing and Test Cases

The goal of the first part of this assignment was to identify bugs across the Django web application. We were then
asked to conduct four attacks that exploit these bugs. To begin, I spent a large amount of time reading throught the code,
particularly, how data was being passed through various functions, how URL post/requests were handled, where authentication
was used, how the website interacted with the database, and so forth. I began to notice a pattern where I could pass arbitrary
code and data to specific functions or variables that did not have sanitation or validation within the source code.

The first step in my test cases was to set up some objects that I could use to manipulate the website. I understood that with each
test run, a 'test' database is created and deleted upon completion of test cases, so I had to initialize some users, a product, and
at one point, a giftcard. I also set up some global variables with URLs I know were susceptible to manipulation via python requests;
whether it was a GET or POST request, I could make injections or output sensitive data.

The first test case I constructed was the CSRF attack. Cross-site Request Forgery (CSRF) is an attack where an attacker essentially
"tricks" a user into submitting unauthorized commands. In my review of the source code, I noticed that the application would 
whatever it would find within its context['director] grab - in this key/pair scenario, there is no input validation or sanitation,
which allows us to exploit this bad code in a myriad of ways. My first attack against it was to setup CSRF. I constructed and hosted
the HTML page (csrf.html) that submitted a POST request against this 'director' dict (with the click of a button). This attack led me
to discover that I cards could be gifted without any authentication (wow), and made it incredibly easy to fool victims into gifting
cards. For testing purposes, I constructed a URL with the HTML form that created the button. Upon manual testing, this button was
completely functional and allowed for a successful attack.

My next attack, cross-site scripting (XSS), involved invoking the same vulnerable variable (director) to inject a script. In this case,
I inject a simple alert() function that could prove my code would be processed and read. In my test case, similarly to CSRF, I constructed
the injection via python requests into a URL containing the payload. The alert was successful and it proved an easy XSS attack.

The next attack hit me at the later stages of my work on this lab: debug mode. In security, this is a given - make sure debug mode is turned
off in production. With debug mode, an adversay can output sensitive data that would have normally been unavailable if this setting was turned
OFF. Debug mode will output information it deems "helpful" for a developer to reconcile errors in a program. With 'settings.DEBUG' turned
to ON, I was able to construct a simple URL to a nonexistent object, and receive a Django debug page that revealed URlconf and
GiftcardSite.urls, providing all relevant URL paths and their input parameters. In this test case, it was a successful attempt at
deriving information that would have normally been completely restricted to third-parties.

The next and final test case for my attack was an SQL injection. This was my most difficult attack to both experiment with and derive a
test case. I found it challenging to accurately manipulate the gift cards so that my SQL query would process, and when it finally did,
it was even more difficult to construct a proper POST. The first place I noticed the admin password was when I uploaded the attack giftcard
to the /use.html form. Django outputted a 404 Debug page, however, the admin password was also outputted as a card object, and so
I was able to successfully conduct the SQL attack and retrieve the admin password. The POST was especially difficult, as I had to properly
read the giftcard file, apply proper encoding, and make certain that my SQL query would pass in the same way.

Ultimately, all of my attacks were successfully implemented.

### Part 2: Encryption

For part 2 of this lab, were asked to add encryption to the database utilized by our webpage. 
Specifically the `data` field of the `LegacySite_card` table. To accomplish this, I incorporated 
the django-cryptography library, which wraps python's own cryptography library as a backend. The first step
was to utilize the `django_cryptography.fields.encrypt` function against the data model in models.py. 
The ultimate goal with this encryption function is to prevent the leakage of sensitive data in case of a data breach.
I made sure to 'makemigrations' and 'migrate' to implement the proper changes against the card 'data' field.

The next step was key management, and I implemented a simple KMS process that allowed for better secrecy 
of my secret key. For all intensive purposes,this KMS process was implemented with the understanding that 
it is completely local, and I should approach the issues at hand as such. With this in mind, I installed
`python-dotenv` to create a local project environment where I would be able to store my key in secret.
My next step was to create a local directory called `.env`; here, I would store the actual value of my
secret key. In settings.py, I reference `SECRET_KEY` by looking for the `.env` file within the `.env` directory,
loading the folder, and extracting the value for use. In a hypothetical push to "production," I would add `.env` to
.gitignore to make certain that hardcoded keys weren't being pushed to production.

In future practice, I would utilize the `python-decouple` library from python's `decouple` method.


