Part 2: Encryption

For part 2 of this lab, were asked to add encryption to the database utilized by our webpage. 
Specifically the `data` field of the `LegacySite_card` table. To accomplish this, I incorporated 
the django-cryptography library, which wraps python's own cryptography library as a backend. The first step
was to utilize the `django_cryptography.fields.encrypt` function against the data model in models.py. 
The ultimate goal with this encryption function is to prevent the leakage of sensitive data in case of a data breach.
I made sure to 'makemigrations' and 'migrate' to implement the proper changes against the card 'data' field.

The next step was key management, and I implemented a simple KMS process that allowed for better secrecy 
of my secret key. For all intensive purposes,this KMS process was implemented with the understanding that 
it is completely local, and I should approach the issues at hand as such. With this in mind, I installed
`python-dotenv` to create a local project environment where I would be able to store my key in secret.
My next step was to create a local directory called `.env`; here, I would store the actual value of my
secret key. In settings.py, I reference `SECRET_KEY` by looking for the `.env` file within the `.env` directory,
loading the folder, and extracting the value for use. In a hypothetical push to "production," I would add `.env` to
.gitignore to make certain that hardcoded keys weren't being pushed to production.

In future practice, I would utilize the `python-decouple` library from python's `decouple` method.